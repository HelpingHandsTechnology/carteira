---
description: server guidelines
globs: src/server/**/*.ts
---
# Elysia Development Guidelines


## Dependency injection

- For routes the services should come via `decorate` instead to be used directly in the body of the function
- Same for the database


## Core Principles

- Use English for all code and documentation
- Leverage end-to-end type safety with Eden Treaty
- Follow RESTful conventions for API routes
- Implement modular architecture with Elysia plugins

## Elysia Server Guidelines

### Basic Structure

- Create modular routers using Elysia plugins
- Use prefix for API versioning and grouping
- Implement proper error handling with onError hooks
- Configure server settings via Elysia constructor

```typescript
import { Elysia } from 'elysia'

const app = new Elysia({ prefix: '/api' })
  .use(userRouter) 
  .use(postRouter)
  .onError(({ error, set }) => {
    set.status = 500
    return { error: error.message }
  })
```

## Ambiente de Desenvolvimento

- Usar sempre Bun ao invés de npm/yarn para todas as operações:
  - Instalação de pacotes: `bun add` ao invés de `npm install`
  - Scripts: `bun run` ao invés de `npm run`
  - Desenvolvimento: `bun dev` ao invés de `npm run dev`
  - Testes: `bun test` ao invés de `npm test`
- Aproveitar as otimizações e velocidade que o Bun oferece
- Manter o bun.lockb no controle de versão

### Route Handlers

- Use descriptive route names in plural form
- Implement proper request validation using Elysia's type system
- Return structured responses with proper status codes
- Document routes with OpenAPI/Swagger annotations

### Model Pattern

- Create a Model class for each resource to handle validation and types
- Models should always be defined in the same file as their corresponding router
- Use static properties for schema definitions
- Reuse validation schemas across routes
- Keep validation logic centralized

```typescript
export class PostModel {
  static id = t.Object({
    id: t.String()
  })

  static create = t.Object({
    name: t.String({ minLength: 1 })
  })

  static update = {
    params: this.id,
    body: this.create
  }

  static delete = {
    params: this.id
  }
}

export const postRouter = new Elysia({ prefix: '/posts' })
  .decorate('postService', new PostService(DbService.db))
  .post('', async ({ body, postService }) => {
    const post = await postService.create(body)
    return post
  }, {
    body: PostModel.create
  })
```

## Eden Treaty Guidelines

### Client Setup

- Export server type for end-to-end type safety([2](mdc:https:/elysiajs.com/eden/treaty/overview.html))
- Configure Eden Treaty with proper base URL
- Implement error handling for API responses
- Use proper TypeScript types for request/response

```typescript
import { treaty } from '@elysiajs/eden'
import type { App } from './server'

const api = treaty<App>('http://localhost:3000')
```

### API Consumption

- Use tree-like syntax for route access([3](mdc:https:/elysiajs.com/eden/treaty/overview.html))
- Handle responses with proper error checking
- Implement proper TypeScript types
- Use proper HTTP methods

```typescript
// GET /api/posts
const { data, error } = await api.posts.get()

// POST /api/posts
const { data, error } = await api.posts.post({
  title: 'Hello',
  content: 'World'
})
```

## Essential Patterns

### Configuration

- Use environment variables for configuration
- Implement proper validation for config values
- Use TypeScript for type-safe configuration
- Follow the principle of least privilege

### Error Handling

- Use `neverthrow` for all error handling in the application
- Never use try/catch directly, always wrap in Result
- Return structured error responses
- Log errors appropriately

#### Error Types

```typescript
// Define domain-specific error types
export type AuthError = 
  | { type: 'INVALID_CREDENTIALS' }
  | { type: 'USER_NOT_FOUND' }
  | { type: 'EMAIL_ALREADY_EXISTS' }

// Use Result for synchronous operations
import { Result, ok, err } from 'neverthrow'

function validatePassword(password: string): Result<string, AuthError> {
  if (password.length < 6) {
    return err({ type: 'INVALID_CREDENTIALS' })
  }
  return ok(password)
}

// Use ResultAsync for asynchronous operations
import { ResultAsync } from 'neverthrow'

function findUser(email: string): ResultAsync<User, AuthError> {
  return ResultAsync.fromPromise(
    db.users.findUnique({ where: { email } }),
    () => ({ type: 'USER_NOT_FOUND' })
  )
}
```

#### Error Handling Patterns

1. Chain Operations with `andThen`:
```typescript
const signupUser = (data: SignupData): ResultAsync<User, AuthError> => {
  return validateUser(data)
    .andThen(createUser)
    .andThen(sendWelcomeEmail)
}
```

2. Transform Errors with `mapErr`:
```typescript
const result = await findUser(email)
  .mapErr((error): ApiError => ({
    code: 'AUTH_ERROR',
    message: getErrorMessage(error)
  }))
```

3. Combine Multiple Results:
```typescript
const results = await ResultAsync.combine([
  validateEmail(email),
  validatePassword(password),
  checkUserExists(email)
])
```

4. Handle Side Effects with `andTee`:
```typescript
const result = await createUser(data)
  .andTee(logUserCreation)
  .andThen(sendWelcomeEmail)
```

#### Response Structure

All API responses should follow this structure:
```typescript
// Success Response
{
  success: true,
  data: T
}

// Error Response
{
  success: false,
  error: {
    code: string
    message: string
    details?: unknown
  }
}
```

#### Best Practices

1. Always define specific error types for each domain
2. Use `ResultAsync.fromPromise` for database operations
3. Chain operations using `andThen` instead of try/catch
4. Transform low-level errors to domain errors using `mapErr`
5. Use `combine` when dealing with multiple Results
6. Log errors at the edge of the system
7. Never expose internal errors to clients
8. Document all possible error types in function signatures

### Testing

- Write unit tests for route handlers
- Test API endpoints with Eden Treaty
- Implement proper test fixtures
- Follow AAA pattern (Arrange-Act-Assert)

```typescript
import { describe, expect, it } from 'bun:test'
import { treaty } from '@elysiajs/eden'
import { app } from './server'

const api = treaty(app)

describe('Posts API', () => {
  it('should create a post', async () => {
    const { data, error } = await api.posts.post({
      title: 'Test',
      content: 'Content'
    })
    
    expect(error).toBeNull()
    expect(data.title).toBe('Test')
  })
})
```

## Best Practices

- Use proper TypeScript types everywhere
- Implement proper validation for all inputs
- Follow REST conventions for API design
- Use proper error handling
- Write comprehensive tests
- Document your API properly
- Use proper logging
- Follow security best practices
- Implement proper CORS handling
- Use proper HTTP methods

## Database Guidelines

### Schema Management

- Use Drizzle ORM for database operations
- Keep schema definitions in `src/server/db/schema.ts`
- Use TypeScript for type-safe schema definitions
- Follow naming conventions (plural for tables, singular for columns)

### Migration Strategy

- Avoid using migrations for development
- Use `drizzle-kit push` for schema updates
- Only use migrations in production environments
- Keep schema changes backwards compatible
- Document breaking changes in schema

### Schema Updates

```typescript
// Use push command for development
bun run drizzle-kit push

// Avoid using migrations during development
// ❌ bun run drizzle-kit generate
// ❌ bun run drizzle-kit migrate
```

### Best Practices for Schema Changes

- Always use `push` command for development
- Test schema changes locally before pushing
- Keep schema changes atomic and focused
- Document schema changes in commit messages
- Use proper column types and constraints
- Implement proper indexes for performance
- Follow naming conventions consistently

### Functional Programming with neverthrow
- Use `.map` instead of `.andThen` for simple transformations
- Only use `.andThen` when you need to chain async operations or handle errors
- Keep transformations pure and side-effect free
- Avoid unnecessary wrapping of values in Result/ResultAsync
- Use `okAsync` and `errAsync` instead of `Promise.resolve/reject`

```typescript
// ❌ Don't use Promise.resolve/reject
return ResultAsync.fromPromise(
  Promise.resolve(value),
  () => ({ type: "ERROR" })
)

// ✅ Use okAsync/errAsync
return okAsync(value)

// ❌ Don't use Promise.reject with ResultAsync.fromPromise
return ResultAsync.fromPromise<never, AuthError>(
  Promise.reject({ type: "NOT_FOUND" }),
  (e) => e as AuthError
)

// ✅ Use errAsync directly
return errAsync({ type: "NOT_FOUND" })

// ❌ Unnecessary Promise wrapping
return ResultAsync.fromPromise(
  Promise.resolve(this.mapToUser(user)),
  () => ({ type: "ERROR" })
)

// ✅ Direct value wrapping
return okAsync(this.mapToUser(user))
```
